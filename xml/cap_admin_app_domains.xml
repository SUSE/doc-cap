<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.0" xml:id="cha.cap.custom-app-domains"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <info>
<!-- TODO review if chapter is still required. See:
  https://github.com/SUSE/doc-cap/issues/283
  -->
  <title>Custom Application Domains</title>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  In a standard &scf; deployment, applications will use the same domain as the
  one configured in your <filename>scf-config-values.yaml</filename> for SCF.
  For example, if your &scf; deployment's domain is set as
  <literal>example.com</literal> then an application's domain will be in the
  form of <literal>myapp.example.com</literal>.
 </para>
 <para>
  This chapter describes the changes required to allow applications to use a
  separate domain.
 </para>
 <sect1 xml:id="sec.cap.customizing-app-domains">
  <title>Customizing Application Domains</title>

  <para>
   Begin by adding the following to your
   <filename>scf-config-values.yaml</filename>. Replace
   <literal>APPDOMAIN</literal> with the domain to use with your applications:
  </para>

<screen>bosh:
  instance_groups:
  - name: api-group
    jobs:
    - name: cloud_controller_ng
      properties:
        app_domains:
	- <replaceable>&lt;APPDOMAIN></replaceable>
</screen>

  <para>
   If UAA is deployed, pass your UAA secret and certificate to SCF. Otherwise
   deploy UAA first (See <xref linkend="sec.cap.install-uaa-prod"/>), then
   proceed with this step:
  </para>

<screen>&prompt.user;SECRET=$(kubectl get pods --namespace uaa \
-o jsonpath='{.items[?(.metadata.name=="uaa-0")].spec.containers[?(.name=="uaa")].env[?(.name=="INTERNAL_CA_CERT")].valueFrom.secretKeyRef.name}')

&prompt.user;CA_CERT="$(kubectl get secret $SECRET --namespace uaa \
-o jsonpath="{.data['internal-ca-cert']}" | base64 --decode -)"
</screen>

  <para>
   If this is an initial deployment, use <command>helm install</command> to
   deploy SCF:
  </para>

<screen>&prompt.user;helm install suse/cf \
--name susecf-scf \
--namespace scf \
--values scf-config-values.yaml \
--set "secrets.UAA_CA_CERT=${CA_CERT}"
</screen>

  <para>
   If this is an existing deployment, use <command>helm upgrade</command> to
   apply the change:
  </para>

<screen>&prompt.user;helm upgrade susecf-scf suse/cf \
--values scf-config-values.yaml --set "secrets.UAA_CA_CERT=${CA_CERT}"
</screen>

  <para>
   Monitor the progess of the deployment:
  </para>

<screen>&prompt.user;watch -c 'kubectl get pods --namespace scf'</screen>

  <para>
   When all pods are in a ready state, do the following to confirm custom
   application domains have been configured correctly.
  </para>

  <para>
   Run <command>cf curl /v2/info</command> and verify the SCF domain is not
   <literal>APPDOMAIN</literal>:
  </para>

<screen>&prompt.user;cf api --skip-ssl-validation https://api.example.com
&prompt.user;cf curl /v2/info | grep endpoint
</screen>

  <para>
   Deploy an application and examine the <literal>routes</literal> field to
   verify <literal>APPDOMAIN</literal> is being used:
  </para>

<screen>&prompt.user;cf login
&prompt.user;cf create-org org
&prompt.user;cf create-space space
&prompt.user;cf target -o org -s space
&prompt.user;cf push myapp
cf push myapp
Pushing app myapp to org org / space space as admin...
Getting app info...
Creating app with these attributes...
  name:       myapp
  path:       /path/to/myapp
  routes:
+   myapp.APPDOMAIN

Creating app myapp...
Mapping routes...

...

Waiting for app to start...

name:              myapp
requested state:   started
instances:         1/1
usage:             1G x 1 instances
routes:            myapp.APPDOMAIN
last uploaded:     Mon 14 Jan 11:08:02 PST 2019
stack:             sle12
buildpack:         ruby
start command:     bundle exec rackup config.ru -p $PORT

     state     since                  cpu    memory       disk          details
#0   running   2019-01-14T19:09:42Z   0.0%   2.7M of 1G   80.6M of 1G
</screen>
 </sect1>
</chapter>
