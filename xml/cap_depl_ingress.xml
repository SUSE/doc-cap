<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.0" xml:id="cha.cap.ingress"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <info>
  <title>Using an Ingress Controller with &cap;</title>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <para>
  An Ingress controller (see <link xlink:href="https://kubernetes.io/docs/concepts/services-networking/ingress/"/>) is a &kube; resource that manages traffic to services in a &kube; cluster.
 </para>

 <para>
  Using an Ingress controller has the benefit of:
 </para>

 <itemizedlist>
  <listitem>
   <para>
    Having only one load balancer.
   </para>
  </listitem>
  <listitem>
   <para>
    SSL can be terminated on the controller.
   </para>
  </listitem>
  <listitem>
   <para>
    All traffic can be routed through ports 80 and 443 on the controller. The
    Ingress routing rules will then manage the traffic flow to the appropriate
    backend services.
   </para>
  </listitem>
 </itemizedlist>

 <para>
  Note that only the NGINX Ingress Controller has been verified to be
  compatible with &cap;. Other Ingress controller alternatives may work, but
  compatibility with &cap; is not supported.
 </para>

 <sect1 xml:id="sec.cap.deploy-ingress-controller">
  <title>Deploying NGINX Ingress Controller</title>

  <procedure>
   <step>
    <para>
     Prepare your &kube; cluster according to the documentation for your platform. Proceed
     to the next step when you reach the <literal>uaa</literal> deployment phase for your
     platform. Note that the DNS sections in the platform-specific documentation can be
     omitted.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       For &caasp;, see <xref linkend="cha.cap.install-production"/>
      </para>
     </listitem>
     <listitem>
      <para>
       For &aks;, see <xref linkend="cha.cap.depl-azure"/>
      </para>
     </listitem>
     <listitem>
      <para>
       For &eks;, see <xref linkend="cha.cap.eks"/>
      </para>
     </listitem>
     <listitem>
      <para>
       For &gke;, see <xref linkend="cha.cap.depl-gke"/>
      </para>
     </listitem>
    </itemizedlist>
   </step>
   <step>
    <para>
     Install the NGINX Ingress Controller.
    </para>
<screen>&prompt.user;helm install suse/nginx-ingress \
--name nginx-ingress \
--namespace ingress \
--set rbac.create=true
</screen>
   </step>
   <step>
    <para>
     Monitor the progess of the deployment:
    </para>
<screen>&prompt.user;watch -c 'kubectl get pods --namespace ingress'</screen>
   </step>
   <step>
    <para>
     After the deployment completes, the Ingress controller service will be deployed
     with either an external IP or a hostname. For &caasp;, &aks;, and &gke;, this
     will be an IP and for &eks;, it will be a hostname. Find the external IP or
     hostname.
    </para>
<screen>&prompt.user;kubectl get services nginx-ingress-controller --namespace ingress</screen>
    <para>
     You will get output similar to the following.
    </para>
<screen>NAME                       TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)                      
nginx-ingress-controller   LoadBalancer   <replaceable>10.63.248.70</replaceable>   <replaceable>35.233.191.177</replaceable>   80:30344/TCP,443:31386/TCP
</screen>
   </step>
   <step>
    <para>
     Set up appropriate DNS records (CNAME for &eks;, A records for &caasp;, &aks;,
     and &gke;) corresponding to the controller service IP or hostname with the following
     entries. Replace <replaceable>example.com</replaceable> with your actual domain.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <replaceable>example.com</replaceable>
      </para>
     </listitem>
     <listitem>
      <para>
       <replaceable>*.example.com</replaceable>
      </para>
     </listitem>
     <listitem>
      <para>
       <replaceable>uaa.example.com</replaceable>
      </para>
     </listitem>
     <listitem>
      <para>
       <replaceable>*.uaa.example.com</replaceable>
      </para>
     </listitem>
    </itemizedlist>
   </step>
   <step>
    <para>
     Obtain a PEM formatted certificate and ensure it includes Subject Alternative
     Names (SAN) for <literal>uaa</literal> and <literal>scf</literal> listed in
     the previous step.
    </para>
   </step>
   <step>
    <para>
     Add the following to your configuration file,
     <filename>scf-config-values.yaml</filename>, to trigger the creation of the Ingress
     objects. Ensure <literal>crt</literal> and <literal>key</literal> are encoded in
     the PEM format. Note the port changes, this ensures all communications to
     <literal>uaa</literal> are routed through the Ingress controller.
    </para>
    <para>
     The <literal>nginx.ingress.kubernetes.io/proxy-body-size</literal> value indicates the maximum
     client request body size. Actions such as pushing an application through <command>cf push</command>
     can result in larger request body sizes depending on the application type you work with. This value
     will need to be adapted to your workflow.
    </para>
<screen>UAA_PORT: 443
UAA_PUBLIC_PORT: 443
...
ingress:
  enabled: true
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: <replaceable>1024m</replaceable>
  tls:
    crt: |
      -----BEGIN CERTIFICATE-----
      MIIE8jCCAtqgAwIBAgIUT/Yu/Sv8AUl5zHXXEKCy5RKJqmYwDQYJKoZIhvcMOQMM
      [...]
      xC8x/+zB7XlvcRJRio6kk670+25ABP==
      -----END CERTIFICATE-----
    key: |
      ----BEGIN CERTIFICATE-----
      MIIE8jCCAtqgAwIBAgIUSI02lj2b2ImLy/zMrjNgW5d8EygwQSVJKoZIhvcYEGAW
      [...]
      to2WV7rPMb9W9fd2vVUXKKHTc+PiNg==
      -----END CERTIFICATE-----
</screen>
   </step>
   <step>
    <para>
     Deploy <literal>uaa</literal>.
    </para>
<screen>&prompt.user;helm install suse/uaa \
--name susecf-uaa \
--namespace uaa \
--values scf-config-values.yaml
</screen>
   </step>
   <step>
    <para>
     Monitor the deployment progress using the <command>watch</command> command. 
    </para>
<screen>&prompt.user;watch -c 'kubectl get pods --namespace uaa'</screen>
   </step>
   <step>
    <para>
     When all <literal>uaa</literal> pods are up and ready, verify
     <literal>uaa</literal> is working. Pass the CA certificate used to sign
     the Ingress controller certificate as the value of
     <command>--cacert</command>.
    </para>
<screen>&prompt.user;curl --cacert <replaceable>INGRESS_CONTROLLER_CA_CERT</replaceable> <replaceable>https://uaa.example.com.com/.well-known/openid-configuration</replaceable></screen>
   </step>
   <step>
    <para>
     Update the Ingress controller to set up TCP forwarding
    </para>
<screen>&prompt.user;helm upgrade nginx-ingress suse/nginx-ingress \
  --reuse-values \
  --set "tcp.20000=scf/tcp-router-tcp-router-public:20000" \
  --set "tcp.20001=scf/tcp-router-tcp-router-public:20001" \
  --set "tcp.20002=scf/tcp-router-tcp-router-public:20002" \
  --set "tcp.20003=scf/tcp-router-tcp-router-public:20003" \
  --set "tcp.20004=scf/tcp-router-tcp-router-public:20004" \
  --set "tcp.20005=scf/tcp-router-tcp-router-public:20005" \
  --set "tcp.20006=scf/tcp-router-tcp-router-public:20006" \
  --set "tcp.20007=scf/tcp-router-tcp-router-public:20007" \
  --set "tcp.20008=scf/tcp-router-tcp-router-public:20008" \
  --set "tcp.2222=scf/diego-ssh-ssh-proxy-public:2222"
</screen>
   </step>
   <step>
    <para>
     Set up the <literal>scf</literal> deployment to trust the CA certificate
     that signed the certificate of the Ingress Controller.
    </para>
<screen>&prompt.user;export INGRESS_CA_CERT=$(cat ingress-ca-cert.pem)</screen>
   </step>
   <step>
    <para>
     Deploy <literal>scf</literal>.
    </para>
<screen>&prompt.user;helm install suse/cf \
--name susecf-scf \
--namespace scf \
--values scf-config-values.yaml \
--set "secrets.UAA_CA_CERT=${INGRESS_CA_CERT}"
</screen>
   </step>
   <step>
    <para>
     Monitor the deployment progress using the <command>watch</command> command.
    </para>
<screen>&prompt.user;watch -c 'kubectl get pods --namespace scf'</screen>
   </step>
   <step>
    <para>
     When all <literal>scf</literal> pods are up and ready, verify
     you are able to login using the &cfcli;.
    </para>	
<screen>&prompt.user;cf login https://api.example.com -u <replaceable>username</replaceable> -p <replaceable>password</replaceable></screen>
   </step>
  </procedure>
 </sect1>
 
 <sect1 xml:id="sec.cap.ingress-body-size">
  <title>Changing the Max Body Size</title>

  <para>
   The <literal>nginx.ingress.kubernetes.io/proxy-body-size</literal> value indicates the maximum
   client request body size. Actions such as pushing an application through <command>cf push</command>
   can result in larger request body sizes depending on the application type you work with. If your
   current setting is insufficient, you may encounter a <literal>413 Request Entity Too Large</literal>
   error.
  </para>

  <para>
   The maximum client request body size can be changed to adapt to your workflow using the following.
  </para>

  <procedure>
   <step>
    <para>
     Add <literal>nginx.ingress.kubernetes.io/proxy-body-size</literal> to your <filename>scf-config-values.yaml</filename>
     and specify a value.
    </para>
<screen>ingress:
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: <replaceable>1024m</replaceable>
</screen>
   </step>
   <step>
    <para>
     Set up the <literal>scf</literal> deployment to trust the CA certificate
     that signed the certificate of the Ingress Controller.
    </para>
<screen>&prompt.user;export INGRESS_CA_CERT=$(cat ingress-ca-cert.pem)</screen>
   </step>
   <step>
    <para>
     Use <command>helm upgrade</command> to apply the change.
    </para>
<screen>&prompt.user;helm upgrade susecf-scf suse/cf \
--values scf-config-values.yaml --set "secrets.UAA_CA_CERT=${INGRESS_CA_CERT}"
</screen>
   </step>
   <step>
    <para>
     Monitor the deployment progress using the <command>watch</command> command.
    </para>
<screen>&prompt.user;watch -c 'kubectl get pods --namespace scf'</screen>
   </step>
  </procedure>
 </sect1>
</chapter>
